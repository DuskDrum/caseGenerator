Z3有约 800个 api，这里罗列出所有的用法


以下是Z3 API中指定方法的分类及逐个解释，按照功能模块分组：

一、错误处理与全局配置
Z3_set_error_handler:设置自定义错误处理回调函数，用于捕获Z3运行时的错误信息。
Z3_global_param_set:设置全局参数（如smt.arith.solver=2或timeout），影响所有后续创建的上下文。
Z3_global_param_reset_all:将所有全局参数重置为默认值。
Z3_global_param_get:查询当前全局参数的值。
Z3_get_global_param_descrs:获取全局参数的描述信息（名称、类型、默认值等），返回Z3_param_descrs对象。

二、上下文与配置管理
Z3_mk_config:创建一个配置对象，用于初始化上下文。
Z3_del_config:销毁配置对象，释放相关内存。
Z3_set_param_value:在配置对象中设置参数（需在创建上下文前调用）。例如设置求解策略。
Z3_mk_context:基于配置对象创建Z3上下文（核心结构，管理所有对象生命周期）。
Z3_mk_context_rc:创建支持引用计数管理的上下文，适用于多线程环境。
Z3_del_context:销毁上下文并释放所有关联资源。
Z3_update_param_value:在已创建的上下文中更新参数值（需确保参数支持运行时修改）。

三、引用计数与内存管理
Z3_inc_ref:增加Z3对象（如表达式、排序）的引用计数，防止被提前回收。
Z3_dec_ref:减少引用计数，当计数归零时自动释放对象。
Z3_enable_concurrent_dec_ref:启用多线程安全的引用计数管理。

四、求解器与传播器扩展
Z3_solver_register_on_clause:注册回调函数，当求解器推导出新子句时触发。
Z3_solver_propagate_init:初始化求解器的传播器，用于自定义理论扩展（如添加变量绑定）。
Z3_solver_propagate_fixed:标记某个变量已被固定为特定值，传播器会据此推断其他变量。
Z3_solver_propagate_eq / Z3_solver_propagate_diseq:向传播器添加等式或不等式的约束条件，用于自定义理论推理。
Z3_solver_propagate_final:结束传播器的初始化阶段，进入求解阶段。

五、优化器与模型事件
Z3_optimize_register_model_eh:注册回调函数，在优化器生成模型时进行自定义处理（如提取特定值）。

六、参数与参数描述管理
Z3_mk_params:创建参数对象，用于设置求解器选项（如超时时间）。
Z3_params_set_bool / Z3_params_set_uint / Z3_params_set_double:设置参数对象的布尔值、无符号整数或浮点数值。
Z3_params_set_symbol:通过符号名称设置参数值（如设置逻辑类型）。
Z3_params_validate:验证参数是否适用于当前求解器。
Z3_params_to_string / Z3_params_to_string_bytes:将参数对象序列化为字符串，用于调试或日志。
Z3_param_descrs_inc_ref / Z3_param_descrs_dec_ref:管理参数描述对象（Z3_param_descrs）的引用计数。
Z3_param_descrs_get_kind:获取参数的类型（布尔型、整型等）。
Z3_param_descrs_get_documentation:获取参数的文档说明（如用途和取值范围）。
Z3_param_descrs_to_string:将参数描述信息格式化为可读字符串。

七、工具与中断控制
Z3_interrupt:请求中断当前求解过程（例如处理超时或用户取消）。

八、其他关键操作
Z3_inc_ref / Z3_dec_ref:管理任意Z3对象（如表达式、模型）的引用计数。
Z3_mk_config / Z3_del_config:配置对象的创建与销毁，用于初始化上下文前的参数设置。




一、参数描述管理
### Z3_param_descrs_size:
功能：获取参数描述对象（Z3_param_descrs）中参数的数量。
参数：(ctx: Z3_context, descrs: Z3_param_descrs)
返回值：unsigned（参数个数）
### Z3_param_descrs_get_name:
功能：根据索引获取参数描述对象中某个参数的名称。
参数：(ctx: Z3_context, descrs: Z3_param_descrs, idx: unsigned)
返回值：Z3_symbol（参数名称的符号）

二、符号与排序创建
### Z3_mk_int_symbol:
功能：通过整数标识符创建符号（例如用于变量或函数名）。
参数：(ctx: Z3_context, i: int)
返回值：Z3_symbol
示例：Z3_mk_int_symbol(ctx, 42) 创建符号名为 42 的符号。
### Z3_mk_string_symbol:
功能：通过字符串名称创建符号（更易读）。
参数：(ctx: Z3_context, s: const char*)
返回值：Z3_symbol
示例：Z3_mk_string_symbol(ctx, "x") 创建符号名为 x。
### Z3_mk_uninterpreted_sort
功能：创建未解释的排序（用户自定义类型，无预定义语义）。
参数：(ctx: Z3_context, name: Z3_symbol)
返回值：Z3_sort
示例：定义类型 Color：
Z3_symbol color_sym = Z3_mk_string_symbol(ctx, "Color");
Z3_sort color_sort = Z3_mk_uninterpreted_sort(ctx, color_sym);
### Z3_mk_type_variable
功能：创建类型变量（用于多态类型，如泛型）。
参数：(ctx: Z3_context, name: Z3_symbol)
返回值：Z3_sort
### Z3_mk_bool_sort / Z3_mk_int_sort / Z3_mk_real_sort
功能：创建基础逻辑类型（布尔、整数、实数）。
参数：(ctx: Z3_context)
返回值：Z3_sort
### Z3_mk_bv_sort
功能：创建指定位数的位向量类型（如32位整数）。
参数：(ctx: Z3_context, width: unsigned)
示例：Z3_mk_bv_sort(ctx, 32) 创建32位位向量类型。
### Z3_mk_finite_domain_sort
功能：创建有限域排序（元素数量固定，如枚举）。
参数：(ctx: Z3_context, name: Z3_symbol, size: uint64_t)
返回值：Z3_sort

三、数据结构与数组
### Z3_mk_array_sort
功能：创建一维数组类型（IndexSort → ElementSort）。
参数：(ctx: Z3_context, domain: Z3_sort, range: Z3_sort)
示例：
Z3_sort int_sort = Z3_mk_int_sort(ctx);
Z3_sort array_sort = Z3_mk_array_sort(ctx, int_sort, int_sort);  // int → int 的数组
### Z3_mk_array_sort_n
功能：创建多维数组类型（支持多个索引域）。
参数：(ctx: Z3_context, n: unsigned, domains: Z3_sort[], range: Z3_sort)
示例：创建二维数组 int[][]：
Z3_sort domains = {int_sort, int_sort};
Z3_sort array2d_sort = Z3_mk_array_sort_n(ctx, 2, domains, int_sort);
### Z3_mk_tuple_sort
功能：创建元组类型（定义多个字段的组合）。
参数：(ctx: Z3_context, name: Z3_symbol, num_fields: unsigned, field_names: Z3_symbol[], field_sorts: Z3_sort[])
示例：定义元组 (int, bool)：
Z3_symbol tuple_sym = Z3_mk_string_symbol(ctx, "Tuple");
Z3_symbol field_names = {"first", "second"};
Z3_sort field_sorts = {int_sort, bool_sort};
Z3_sort tuple_sort = Z3_mk_tuple_sort(ctx, tuple_sym, 2, field_names, field_sorts);
### Z3_mk_enumeration_sort
功能：创建枚举类型（如 enum {Red, Green, Blue}）。
参数：(ctx: Z3_context, name: Z3_symbol, num_enums: unsigned, enum_names: const char*[])
示例：
const char* colors[] = {"Red", "Green", "Blue"};
Z3_sort color_sort = Z3_mk_enumeration_sort(ctx, color_sym, 3, colors);
### Z3_mk_list_sort
功能：创建链表类型（递归定义，如 List = Nil | Cons(T, List)）。
参数：(ctx: Z3_context, name: Z3_symbol, elem_sort: Z3_sort)
示例：
Z3_symbol list_sym = Z3_mk_string_symbol(ctx, "IntList");
Z3_sort list_sort = Z3_mk_list_sort(ctx, list_sym, int_sort);

四、构造函数与数据类型
### Z3_mk_constructor
功能：为自定义数据类型（ADT）创建构造函数（如 Cons 用于链表）。
参数：
(ctx: Z3_context, name: Z3_symbol, recognizer: Z3_symbol,
num_fields: unsigned, field_names: Z3_symbol[], field_sorts: Z3_sort[])
返回值：Z3_constructor
### Z3_constructor_num_fields
功能：获取构造函数的字段数量。
参数：(ctx: Z3_context, c: Z3_constructor)
返回值：unsigned
### Z3_del_constructor
功能：销毁构造函数对象，释放内存。
参数：(ctx: Z3_context, c: Z3_constructor)
### Z3_mk_datatype
功能：创建自定义数据类型（ADT），需提供构造函数列表。
参数：(ctx: Z3_context, name: Z3_symbol, num_constructors: unsigned, constructors: Z3_constructor[])
示例：定义链表类型 List：
Z3_constructor nil = ...;  // 定义 Nil 构造函数
Z3_constructor cons = ...; // 定义 Cons 构造函数
Z3_constructor cons_list = {nil, cons};
Z3_sort list_sort = Z3_mk_datatype(ctx, list_sym, 2, cons_list);
### Z3_query_constructor
功能：查询构造函数的详细信息（字段名、类型等）。
参数：(ctx: Z3_context, c: Z3_constructor, ...)

五、函数与常量声明
### Z3_mk_func_decl
功能：声明函数（如 f: Int → Bool）。
参数：(ctx: Z3_context, name: Z3_symbol, domain: Z3_sort[], range: Z3_sort)
示例：
Z3_sort domain = {int_sort};
Z3_func_decl f = Z3_mk_func_decl(ctx, f_sym, 1, domain, bool_sort);
### Z3_mk_app
功能：应用函数到参数（创建函数调用表达式）。
参数：(ctx: Z3_context, f: Z3_func_decl, num_args: unsigned, args: Z3_ast[])
示例：f(5) 的表达式：
Z3_ast arg = Z3_mk_int(ctx, 5, int_sort);
Z3_ast app = Z3_mk_app(ctx, f, 1, &arg);
### Z3_mk_const
功能：创建常量（未解释的变量）。
参数：(ctx: Z3_context, name: Z3_symbol, sort: Z3_sort)
示例：
Z3_symbol x_sym = Z3_mk_string_symbol(ctx, "x");
Z3_ast x = Z3_mk_const(ctx, x_sym, int_sort);
### Z3_mk_fresh_const
功能：生成唯一名称的常量（避免名称冲突）。
参数：(ctx: Z3_context, prefix: const char*, sort: Z3_sort)
示例：Z3_mk_fresh_const(ctx, "x", int_sort) 生成类似 x!0 的常量。
六、逻辑表达式
### Z3_mk_true / Z3_mk_false
功能：创建逻辑常量 true 或 false。
参数：(ctx: Z3_context)
返回值：Z3_ast
### Z3_mk_eq
功能：创建等式表达式（a = b）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
Z3_ast eq = Z3_mk_eq(ctx, x, y);  // x = y
### Z3_mk_distinct
功能：创建互斥表达式（所有参数互不相等）。
参数：(ctx: Z3_context, num_args: unsigned, args: Z3_ast[])
示例：x ≠ y ∧ y ≠ z：
Z3_ast args = {x, y, z};
Z3_ast distinct = Z3_mk_distinct(ctx, 3, args);
### Z3_mk_not
功能：创建逻辑非表达式（¬a）。
参数：(ctx: Z3_context, a: Z3_ast)
### Z3_mk_ite
功能：创建条件表达式（If-Then-Else）。
参数：(ctx: Z3_context, cond: Z3_ast, t: Z3_ast, e: Z3_ast)
示例：if x > 0 then y else z：
Z3_ast cond = Z3_mk_gt(ctx, x, Z3_mk_int(ctx, 0, int_sort));
Z3_ast ite = Z3_mk_ite(ctx, cond, y, z);
### Z3_mk_iff
功能：创建双向蕴含表达式（a ↔ b）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
### Z3_mk_implies(a, b)
创建逻辑蕴含表达式（a → b），当a为真时b必须为真。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast) → Z3_ast
### Z3_mk_xor(a, b)
创建异或表达式（a ⊕ b），当且仅当a和b取值不同时为真。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast) → Z3_ast
### Z3_mk_and(num_args, args)
创建多参数的逻辑与表达式（a₁ ∧ a₂ ∧ ... ∧ aₙ）。
参数：(ctx: Z3_context, num_args: unsigned, args: Z3_ast[]) → Z3_ast
### Z3_mk_or(num_args, args)
创建多参数的逻辑或表达式（a₁ ∨ a₂ ∨ ... ∨ aₙ）。
参数：同Z3_mk_and
### Z3_mk_add(num_args, args)
创建加法表达式（a₁ + a₂ + ... + aₙ），支持整数和实数。
参数：(ctx: Z3_context, num_args: unsigned, args: Z3_ast[]) → Z3_ast
### Z3_mk_sub(num_args, args)
创建减法表达式（a₁ - a₂ - ... - aₙ）。
参数：同上
### Z3_mk_mul(num_args, args)
创建乘法表达式（a₁ * a₂ * ... * aₙ）。
参数：同上
### Z3_mk_unary_minus(a)
创建一元负号表达式（-a）。
参数：(ctx: Z3_context, a: Z3_ast) → Z3_ast
### Z3_mk_div(a, b)
创建实数除法表达式（a / b，结果可能为小数）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast) → Z3_ast
### Z3_mk_mod(a, b)
创建整数取模表达式（a mod b，结果符号与b一致）。
参数：同上
### Z3_mk_rem(a, b)
创建整数取余表达式（a rem b，结果符号与a一致）。
参数：同上
### Z3_mk_power(a, n)
创建幂表达式（a^n），仅支持整数和实数。
参数：(ctx: Z3_context, a: Z3_ast, n: Z3_ast) → Z3_ast
### Z3_mk_abs(a)
创建绝对值表达式（|a|）。
参数：(ctx: Z3_context, a: Z3_ast) → Z3_ast
### Z3_mk_lt(a, b)
创建小于比较（a < b）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast) → Z3_ast
### Z3_mk_le(a, b)
创建小于等于比较（a ≤ b）。
参数：同上
### Z3_mk_gt(a, b)
创建大于比较（a > b）。
参数：同上
### Z3_mk_ge(a, b)
创建大于等于比较（a ≥ b）。
参数：同上
### Z3_mk_divides(a, b)
检查整数是否整除（a | b）。
参数：同上
### Z3_mk_int2real(a)
将整数转换为实数（例如2转为2.0）。
参数：(ctx: Z3_context, a: Z3_ast) → Z3_ast
### Z3_mk_real2int(a)
将实数截断为整数（例如3.7转为3）。
参数：同上
### Z3_mk_is_int(a)
检查实数是否为整数（例如5.0返回true）。
参数：同上
### Z3_mk_bvnot(a)
按位取反（~a）。
参数：(ctx: Z3_context, a: Z3_ast) → Z3_ast
### Z3_mk_bvredand(a)
位向量归约与（所有位进行逻辑与，返回1位结果）。
参数：同上
### Z3_mk_bvand(a, b)
按位与（a & b）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast) → Z3_ast
### Z3_mk_bvor(a, b)
按位或（a | b）。
参数：同上
### Z3_mk_bvxor(a, b)
按位异或（a ^ b）。
参数：同上
### Z3_mk_bvnand(a, b)
按位与非（~(a & b)）。
参数：同上
### Z3_mk_bvneg(a)
位向量算术负号（补码取反加1）。
参数：(ctx: Z3_context, a: Z3_ast) → Z3_ast
### Z3_mk_bvadd(a, b)
位向量加法（无符号加法）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast) → Z3_ast
### Z3_mk_bvudiv(a, b)
无符号位向量除法（结果向下取整）。
参数：同上
### Z3_mk_bvsdiv(a, b)
有符号位向量除法（结果向零取整）。
参数：同上
### Z3_mk_bvult(a, b)
无符号小于比较（a <u b）。
参数：同上
### Z3_mk_bvslt(a, b)
有符号小于比较（a <s b）。
参数：同上
### Z3_mk_bvugt(a, b)
无符号大于比较（a >u b）。
参数：同上
### Z3_mk_bvsgt(a, b)
功能：有符号位向量的大于比较（a >s b）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
示例：比较两个32位有符号整数是否满足 x > y。
### Z3_mk_concat(a, b)
功能：连接两个位向量，结果长度为两者之和。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
示例：连接 8位向量 a 和 4位向量 b，得到 12位向量。
### Z3_mk_extract(high, low, a)
功能：提取位向量的子部分（从高位 high 到低位 low）。
参数：(ctx: Z3_context, high: unsigned, low: unsigned, a: Z3_ast)
示例：从32位向量中提取低8位：Z3_mk_extract(ctx, 7, 0, x)。
### Z3_mk_sign_ext(n, a)
功能：符号扩展位向量，扩展 n 位（保留符号位）。
参数：(ctx: Z3_context, n: unsigned, a: Z3_ast)
示例：将8位有符号数扩展为16位：Z3_mk_sign_ext(ctx, 8, x)。
### Z3_mk_zero_ext(n, a)
功能：零扩展位向量，扩展 n 位（高位补0）。
参数：同上。
### Z3_mk_repeat(n, a)
功能：将位向量重复拼接 n 次。
参数：(ctx: Z3_context, n: unsigned, a: Z3_ast)
示例：重复 4位向量 0b1010 3次，得到 12位向量 0b101010101010。
### Z3_mk_bit2bool(a, idx)
功能：将位向量的第 idx 位转换为布尔值。
参数：(ctx: Z3_context, idx: unsigned, a: Z3_ast)
示例：检查32位整数 x 的第5位是否为1。
### Z3_mk_bvshl(a, b) / Z3_mk_bvlshr(a, b) / Z3_mk_bvashr(a, b)
功能：位向量左移（<<）、逻辑右移（>>>）、算术右移（>>）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
区别：算术右移保留符号位，逻辑右移补0。
### Z3_mk_rotate_left(n, a) / Z3_mk_rotate_right(n, a)
功能：循环左移或右移 n 位（固定位数）。
参数：(ctx: Z3_context, n: unsigned, a: Z3_ast)
示例：将8位向量 0b10000001 循环左移1位得到 0b00000011。
### Z3_mk_ext_rotate_left(a, b) / Z3_mk_ext_rotate_right(a, b)
功能：循环左移或右移可变位数（由位向量 b 的值决定）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
### Z3_mk_int2bv(n, a)
功能：将整数转换为 n 位位向量（可能截断或符号扩展）。
参数：(ctx: Z3_context, n: unsigned, a: Z3_ast)
示例：将整数 5 转为8位位向量 0b00000101。
### Z3_mk_bv2int(a, is_signed)
功能：将位向量转换为整数（有符号或无符号）。
参数：(ctx: Z3_context, a: Z3_ast, is_signed: bool)
### Z3_mk_bvadd_no_overflow(a, b, is_signed)
功能：检查有符号/无符号位向量加法是否溢出。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast, is_signed: bool)
返回值：布尔表达式，表示无溢出。
### Z3_mk_select(array, index)
功能：读取数组元素（array[index]）。
参数：(ctx: Z3_context, array: Z3_ast, index: Z3_ast)
### Z3_mk_select_n(array, indices)
功能：读取多维数组元素（array[i1][i2]...）。
参数：(ctx: Z3_context, array: Z3_ast, num_indices: unsigned, indices: Z3_ast[])
### Z3_mk_store(array, index, value)
功能：更新数组元素（array[index := value]）。
参数：(ctx: Z3_context, array: Z3_ast, index: Z3_ast, value: Z3_ast)
### Z3_mk_store_n(array, indices, value)
功能：更新多维数组元素。
参数：类似 Z3_mk_select_n。
### Z3_mk_const_array(sort, value)
功能：创建所有元素为 value 的常量数组。
参数：(ctx: Z3_context, sort: Z3_sort, value: Z3_ast)
示例：const_array = Z3_mk_const_array(ctx, int_array_sort, Z3_mk_int(ctx, 0))。
### Z3_mk_map(f, arrays)
功能：将函数 f 逐元素应用于多个数组，生成新数组。
参数：(ctx: Z3_context, f: Z3_func_decl, num_arrays: unsigned, arrays: Z3_ast[])
### Z3_mk_set_sort(element_sort)
功能：创建集合类型（元素类型为 element_sort）。
参数：(ctx: Z3_context, element_sort: Z3_sort)
### Z3_mk_empty_set(sort)
功能：创建空集合。
参数：(ctx: Z3_context, sort: Z3_sort)
### Z3_mk_full_set(sort)
功能：创建全集（包含所有可能元素）。
参数：同上。
### Z3_mk_set_add(set, elem)
功能：向集合中添加元素。
参数：(ctx: Z3_context, set: Z3_ast, elem: Z3_ast)
### Z3_mk_set_union(a, b)
功能：求两个集合的并集（a ∪ b）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
### Z3_mk_set_member(elem, set)
功能：检查元素是否属于集合（elem ∈ set）。
参数：(ctx: Z3_context, elem: Z3_ast, set: Z3_ast)
### Z3_mk_numeral(num_str, sort)
功能：根据字符串创建数值常量（整数、实数或位向量）。
参数：(ctx: Z3_context, num_str: const char*, sort: Z3_sort)
示例：Z3_mk_numeral(ctx, "123", int_sort) 创建整数123。
### Z3_mk_int(n, sort)
功能：创建整数常量（n 为 int64_t）。
参数：(ctx: Z3_context, n: int64_t, sort: Z3_sort)
### Z3_mk_unsigned_int(n, sort)
功能：创建无符号整数常量。
参数：同上。
### Z3_mk_array_ext(a, b)
功能：求两个数组的扩展（差异部分）。
参数：(ctx: Z3_context, a: Z3_ast, b: Z3_ast)
### Z3_mk_real(numerator, denominator)
功能：创建分数形式的实数（如 3/2）。
参数：(ctx: Z3_context, numerator: int, denominator: int)
### Z3_mk_bvadd_no_overflow
位向量溢出检查：Z3_mk_bvadd_no_overflow 等函数用于验证运算是否溢出，常用于安全关键代码验证。
集合与数组区别：集合是无序且元素唯一的，数组是映射结构。
数值类型：使用 Z3_mk_int 和 Z3_mk_unsigned_int 时需确保 sort 匹配位宽
### Z3_mk_int64(ctx, n, sort)
功能：创建有符号64位整数常量。
参数：
n: int64_t：整数值。
sort: Z3_sort：必须为整数或位向量类型。
Z3_ast x = Z3_mk_int64(ctx, -42, Z3_mk_int_sort(ctx));  // 创建整数 -42
### Z3_mk_unsigned_int64(ctx, n, sort)
功能：创建无符号64位整数常量。
参数：同上，但 n 被视为无符号数。
Z3_ast y = Z3_mk_unsigned_int64(ctx, 42, Z3_mk_bv_sort(ctx, 64));  // 创建64位无符号位向量 42
### Z3_mk_bv_numeral(ctx, num_bits, bits)
功能：根据二进制字符串创建位向量常量。
参数：
num_bits: unsigned：位向量长度。
bits: const char*：二进制字符串（如 "1010"）。
示例：
Z3_ast bv = Z3_mk_bv_numeral(ctx, 4, "1100");  // 4位位向量 0b1100（值12）
### Z3_mk_seq_sort(ctx, basis_sort)
功能：创建序列类型（元素类型为 basis_sort）。
参数：basis_sort: Z3_sort（基础类型，如整数或字符）。
示例：
Z3_sort int_sort = Z3_mk_int_sort(ctx);
Z3_sort seq_int_sort = Z3_mk_seq_sort(ctx, int_sort);  // 整数序列类型
### Z3_is_seq_sort(ctx, sort)
功能：检查排序是否为序列类型。
返回值：Z3_bool（true/false）。
### Z3_get_seq_sort_basis(ctx, sort)
功能：获取序列类型的基础元素排序。
示例：
Z3_sort basis = Z3_get_seq_sort_basis(ctx, seq_int_sort);  // 返回 int_sort
### Z3_mk_re_sort(ctx, basis_sort)
功能：创建正则表达式类型（基于 basis_sort 的序列）。
示例：
Z3_sort re_sort = Z3_mk_re_sort(ctx, int_sort);  // 匹配整数序列的正则表达式类型
### Z3_is_re_sort(ctx, sort)
功能：检查排序是否为正则表达式类型。
### Z3_mk_string_sort(ctx)
功能：创建字符串排序（等同于 Z3_mk_seq_sort(ctx, Z3_mk_char_sort(ctx))）。
示例：
Z3_sort str_sort = Z3_mk_string_sort(ctx);  // 字符串类型
### Z3_mk_char_sort(ctx)
功能：创建字符排序（Unicode字符，底层为16位无符号整数）。
### Z3_is_string_sort(ctx, sort) / Z3_is_char_sort(ctx, sort)
功能：检查是否为字符串或字符排序。
### Z3_mk_string(ctx, s)
功能：创建字符串常量（UTF-8编码）。
参数：s: const char*（C风格字符串）。
示例：
Z3_ast str = Z3_mk_string(ctx, "hello");  // 字符串 "hello"
### Z3_mk_lstring(ctx, s, len)
功能：创建带显式长度的字符串（处理含\0的字符串）。
参数：len: unsigned（字符串字节长度）。
### Z3_is_string(ctx, a)
功能：检查AST节点是否为字符串常量。
### Z3_get_string(ctx, a, &len)
功能：获取字符串常量的内容。
参数：
a: Z3_ast：字符串AST节点。
len: unsigned*：输出字符串长度。
返回值：const char*（需调用方不释放内存）。
### Z3_mk_seq_empty(ctx, sort)
功能：创建空序列。
示例：
Z3_ast empty = Z3_mk_seq_empty(ctx, str_sort);  // 空字符串 ""
### Z3_mk_seq_concat(ctx, num_args, args)
功能：连接多个序列。
示例：
Z3_ast args[] = {str1, str2};
Z3_ast concat = Z3_mk_seq_concat(ctx, 2, args);  // str1 + str2
### Z3_mk_seq_prefix(ctx, a, b)
功能：判断 a 是否是 b 的前缀。
返回值：布尔表达式。
### Z3_mk_seq_contains(ctx, a, b)
功能：判断 a 是否包含子序列 b。
示例：
Z3_ast contains = Z3_mk_seq_contains(ctx, str, substr);  // str.contains(substr)
### Z3_mk_seq_length(ctx, a)
功能：获取序列长度。
返回值：整数表达式。
示例：
Z3_ast len = Z3_mk_seq_length(ctx, str);  // len(str)
### Z3_mk_seq_extract(ctx, a, offset, len)
功能：提取子序列（从 offset 开始，长度为 len）。
示例：
Z3_ast substr = Z3_mk_seq_extract(ctx, str, 2, 3);  // str[2:5]=
### Z3_mk_seq_map(ctx, f, seq)
功能：将函数 f 应用到序列的每个元素，生成新序列。
参数：
f: Z3_func_decl（函数声明）。
seq: Z3_ast（输入序列）。
示例：将字符串每个字符转为大写。
### Z3_mk_seq_foldl(ctx, f, init, seq)
功能：左折叠（累积操作）。
参数：
f: Z3_func_decl（二元累积函数）。
init: Z3_ast（初始值）。
示例：计算序列元素之和。
### Z3_mk_str_lt(ctx, a, b) / Z3_mk_str_le(ctx, a, b)
功能：字符串字典序比较（小于或小于等于）。
### Z3_mk_seq_nth(ctx, a, n)
功能：获取序列第 n 个元素（索引从0开始）。
示例：
Z3_ast third_char = Z3_mk_seq_nth(ctx, str, 2);  // str
### Z3_mk_str_to_int(ctx, s)
作用：将字符串s转换为整数表达式。若字符串无法转为整数（如"abc"），结果为未定义。
示例：str.to.int("123") 返回整数123。
### Z3_mk_int_to_str(ctx, i)
作用：将整数表达式i转换为字符串形式。
示例：int.to.str(456) 返回字符串"456"。
### Z3_mk_string_to_code(ctx, s)
作用：返回字符串s首字符的ASCII码整数表达式（若字符串为空则无效）。
示例：str.code("A") 返回65。
### Z3_mk_string_from_code(ctx, i)
作用：将整数i转换为对应ASCII字符的字符串。
示例：str.from_code(66) 返回字符串"B"。
### Z3_mk_char(ctx, code)
作用：创建表示Unicode字符的表达式。
示例：char(0x61) 表示字符'a'。
### Z3_mk_seq_to_re(ctx, s)
作用：将字符串s转换为匹配该字符串的正则表达式。
示例：str.to.re("abc") 匹配"abc"。
### Z3_mk_re_plus(ctx, re)
作用：创建匹配至少一次re的正则表达式（re+）。
示例：(re.plus (str.to.re "a")) 匹配"a", "aa"等。
### Z3_mk_re_concat(ctx, re1, re2)
作用：连接两个正则表达式re1和re2。
示例：(re.concat re1 re2) 匹配re1后跟re2的序列。
### Z3_mk_forall(ctx, weight, patterns, sorts, names, body)
作用：创建全称量词，绑定变量列表。
参数：
sorts: 变量类型数组
names: 变量名数组
body: 量词作用域的公式
示例：∀x:Int. x > 0
### Z3_mk_exists(ctx, ...)
类似Z3_mk_forall，但创建存在量词。
### Z3_mk_linear_order(ctx, rel)
作用：断言二元关系rel是线性序（满足全序性）。
示例：定义<关系为线性序。
### Z3_mk_transitive_closure(ctx, rel)
作用：创建关系rel的传递闭包。
示例：若rel是父子关系，传递闭包表示祖先关系。
### Z3_mk_pattern(ctx, terms)
作用：创建模式（用于指导量词实例化）。
示例：在量词中使用模式pattern(f(x))指导求解器。
### Z3_mk_bound(ctx, index, sort)
作用：创建绑定变量（用于量词体内）。
示例：在∀x. P(x)中，x是绑定变量。
### Z3_mk_ubv_to_str(ctx, bv)
作用：将无符号位向量转换为十进制字符串。
示例：bv2str(8'b1010) 返回"10"。
### Z3_mk_char_from_bv(ctx, bv)
作用：将位向量解释为Unicode字符。
示例：char.from_bv(0x61) 得到字符'a'。
### Z3_mk_re_complement(ctx, re)
作用：创建匹配不在re中的字符串的正则表达式。
示例：(re.complement (str.to.re "a")) 匹配非"a"的字符。
### Z3_mk_tree_order(ctx, rel)
作用：定义树形序关系（如父子关系的层次结构）。
使用建议
参数检查：确保传入的上下文(ctx)和参数类型正确。
组合使用：正则表达式函数常组合使用，如：
re_concat = Z3_mk_re_concat(ctx, re_a, re_b)  # 连接两个正则表达式
Z3_ast var = Z3_mk_bound(ctx, 0, int_sort);
Z3_ast body = Z3_mk_gt(ctx, var, Z3_mk_int(ctx, 0, int_sort));
Z3_ast forall = Z3_mk_forall(ctx, 0, 0, 0, 1, &var, body);
### Z3_mk_transitive_closure(ctx, rel)
作用：为二元关系 rel 创建传递闭包。例如，若 rel 是父子关系，传递闭包表示祖先关系。
参数：rel 是二元关系谓词（如 Z3_decl 类型）。
trans_closure = Z3_mk_transitive_closure(ctx, edge)
### Z3_mk_pattern(ctx, num_patterns, terms)
作用：创建量词实例化的模式（用于指导求解器触发量词实例化的条件）。
参数：terms 是模式中的项数组，num_patterns 是数组长度。
Z3_ast patterns = { Z3_mk_eq(ctx, x, f(x)) };
Z3_pattern pattern = Z3_mk_pattern(ctx, 1, patterns);
### Z3_mk_bound(ctx, index, sort)
作用：创建量词体内的绑定变量（如 ∀x. P(x) 中的 x）。
参数：index 是变量在量词中的位置（从0开始），sort 是变量类型。
Z3_ast x = Z3_mk_bound(ctx, 0, int_sort);  // 创建变量 x: Int
### Z3_mk_forall / Z3_mk_exists(ctx, weight, num_patterns, patterns, num_decls, sorts, names, body)
作用：创建全称/存在量词。
参数：
sorts: 变量类型数组（如 Z3_sort[]）。
names: 变量名数组（符号类型，Z3_symbol[]）。
body: 量词作用域的公式。
### Z3_mk_quantifier / Z3_mk_quantifier_ex
作用：通用的量词构造函数，支持更复杂的参数（如多变量绑定、触发条件等）。
区别：Z3_mk_quantifier_ex 允许指定额外的标志（flags）和元数据。 
### Z3_mk_forall_const / Z3_mk_exists_const
作用：通过常量（而非符号）直接创建量词，简化绑定变量的构造。
参数：直接传入常量数组和公式。 
### Z3_mk_lambda / Z3_mk_lambda_const
作用：创建 Lambda 表达式（匿名函数），用于定义高阶逻辑。
### Z3_get_symbol_kind(ctx, sym)
作用：获取符号的类型，返回 Z3_symbol_kind（整数符号或字符串符号）。
返回值：Z3_INT_SYMBOL 或 Z3_STRING_SYMBOL。
### Z3_get_symbol_int(ctx, sym) / Z3_get_symbol_string(ctx, sym)
作用：获取符号的值（整数或字符串形式）。
### Z3_get_sort_name(ctx, sort)
作用：获取排序的名称（如 Int、Bool 或自定义类型名）。
### Z3_is_eq_sort(ctx, s1, s2)
作用：判断两个排序是否相同。
返回值：Z3_TRUE 或 Z3_FALSE。
### Z3_get_sort_kind(ctx, sort)
作用：获取排序的类型（如 Z3_BOOL_SORT、Z3_BV_SORT 等）。
### Z3_get_bv_sort_size(ctx, bv_sort)
作用：获取位向量类型的位宽。
### Z3_get_array_sort_domain / Z3_get_array_sort_range(ctx, array_sort)
作用：获取数组类型的域（索引类型）和范围（值类型）。
### Z3_get_tuple_sort_mk_decl(ctx, tuple_sort)
作用：获取元组类型的构造函数声明（用于创建元组实例）。
### Z3_get_tuple_sort_num_fields(ctx, tuple_sort)
作用：获取元组类型的字段数量。
### Z3_sort_to_ast(ctx, sort)
作用：将排序转换为AST节点，便于统一处理。
### Z3_mk_seq_index(ctx, seq, subseq)
功能：返回子序列 subseq 在 seq 中首次出现的起始索引（未找到则返回 -1）。
参数：
seq: Z3_ast：目标序列。
subseq: Z3_ast：待查找的子序列。
### Z3_mk_seq_last_index(ctx, seq, subseq)
功能：返回子序列 subseq 在 seq 中最后一次出现的起始索引。
参数：同上。
### Z3_mk_seq_map(ctx, f, seq)
功能：将函数 f 应用到序列 seq 的每个元素，生成新序列。
参数：
f: Z3_func_decl：接受一个元素并返回新元素的函数。
### Z3_mk_seq_mapi(ctx, f, seq)
功能：类似 map，但函数 f 额外接收元素索引作为参数。
### Z3_mk_seq_foldl(ctx, f, init, seq)
功能：从左到右对序列进行累积操作（左折叠），初始值为 init。
参数：
f: Z3_func_decl：二元函数，参数为累积值和当前元素。
### Z3_mk_seq_foldli(ctx, f, init, seq)
功能：类似 foldl，但函数 f 额外接收元素索引作为参数。
示例：
// 累积操作：结果 = 初始值 + (元素值 * 索引)
// 序列 [2, 3, 4] → 0 + (2*0) + (3*1) + (4*2) = 0 + 0 + 3 + 8 = 11
Z3_ast result = Z3_mk_seq_foldli(ctx, mul_idx_func, zero, seq);
### Z3_get_datatype_sort_num_constructors(ctx, sort)
作用：获取代数数据类型（ADT）的构造函数数量。例如，List 类型可能包含 nil 和 cons 两个构造器。
示例：若定义 List 类型包含 nil 和 cons，返回值为2。
### Z3_get_datatype_sort_constructor(ctx, sort, idx)
作用：获取指定索引的构造函数声明。用于访问ADT的具体构造逻辑。
参数：idx 表示构造函数索引（从0开始）。
### Z3_datatype_update_field(ctx, dt, field_idx, new_value)
作用：更新ADT实例的某个字段值，返回新实例。类似于结构体字段修改。
示例：修改链表节点的值字段。
### Z3_get_relation_arity(ctx, rel_sort)
作用：获取关系类型的列数（类似于数据库表的列数）。
示例：关系 R(x:Int, y:Bool) 的 arity 为2。
### Z3_get_relation_column(ctx, rel_sort, col_idx)
作用：获取关系类型中指定列的排序（数据类型）。
参数：col_idx 为列索引。
### Z3_mk_atmost(ctx, num_args, args, k)
作用：断言最多有 k 个布尔变量为真。
示例：atmost([x, y, z], 2) 表示三者中至多两个为真。
### Z3_mk_pble(ctx, args, coeffs, k)
作用：创建线性伪布尔不等式，形式为 Σ(coeffs[i] * args[i]) ≤ k。
示例：3x + 2y ≤ 5 约束。
### Z3_get_decl_name(ctx, decl)
作用：获取函数/常量声明的符号名称。
示例：函数 f 的声明返回符号 "f"。
### Z3_get_arity(ctx, decl)
作用：获取函数声明的参数数量。
示例：函数 f(x:Int, y:Bool) 的 arity 为2。
### Z3_get_decl_int_parameter(ctx, decl, idx)
作用：获取函数声明中整数类型的参数值。
示例：BitVec(8) 的 int_parameter 为8。
### Z3_get_decl_num_parameters(ctx, decl)
作用：获取函数声明中附加参数的总数。
示例：BitVec 类型声明包含位宽参数。
### Z3_get_decl_symbol_parameter(ctx, decl, idx)
作用：获取符号类型的参数（如变量名或标签）。
### Z3_is_eq_func_decl(ctx, decl1, decl2)
作用：判断两个函数声明是否相同。
返回值：Z3_TRUE 或 Z3_FALSE。
### Z3_func_decl_to_ast(ctx, decl)
作用：将函数声明转换为AST节点，便于统一处理。
示例：创建伪布尔约束
// 断言 x + y + z ≥ 2
solver.add(Z3_mk_pbge(ctx, [x, y, z], [1,1,1], 2))  # :ml-citation{ref="6,7" data="citationList"}
### Z3_app_to_ast(ctx, app)
功能：将应用（application）节点转换为通用 AST 节点。
参数：app: Z3_app（应用节点）。
返回值：Z3_ast（通用 AST 节点）。
### Z3_get_app_decl(ctx, app)
功能：获取应用节点对应的函数声明（如运算符或函数符号）。
示例：对表达式 f(x, y)，返回函数 f 的声明。
### Z3_get_app_num_args(ctx, app)
功能：获取应用节点的参数数量。
示例：表达式 f(x, y) 的参数数量为 2。
### Z3_get_app_arg(ctx, app, idx)
功能：获取应用节点的第 idx 个参数（索引从 0 开始）。
### Z3_is_eq_ast(ctx, a, b)
功能：判断两个 AST 节点是否结构相同（指针级别或值级别）。
返回值：Z3_bool（true/false）。
### Z3_get_ast_id(ctx, a)
功能：获取 AST 的唯一标识符（用于哈希或比较）。
### Z3_get_ast_hash(ctx, a)
功能：计算 AST 的哈希值（用于快速比较或存储）。
### Z3_get_sort(ctx, a)
功能：获取 AST 节点的排序（数据类型，如整数、位向量）。
示例：表达式 x + 1 的排序为整数类型。
### Z3_is_well_sorted(ctx, a)
功能：检查 AST 是否符合上下文中的类型约束（是否“良构”）。
### Z3_get_bool_value(ctx, a)
功能：获取布尔类型 AST 的值（Z3_L_TRUE/Z3_L_FALSE/Z3_L_UNDEF）。
### Z3_get_ast_kind(ctx, a)
功能：返回 AST 的类型（如 Z3_NUMERAL_AST、Z3_APP_AST）。
### Z3_is_app(ctx, a)
功能：判断 AST 是否为应用节点（包含函数调用或运算符）。
### Z3_is_ground(ctx, a)
功能：检查 AST 是否为“基项”（不含未绑定变量）。
### Z3_is_numeral_ast(ctx, a)
功能：判断 AST 是否表示数值常量（整数、实数或位向量）。
### Z3_is_algebraic_number(ctx, a)
功能：检查 AST 是否为代数数（如 √2）。
### Z3_get_numeral_string(ctx, a)
功能：将数值 AST 转换为十进制字符串（整数或实数）。
示例：数值 42 转换为 "42"。
### Z3_get_numeral_binary_string(ctx, a)
功能：将位向量数值转换为二进制字符串（如 0b1010）。
### Z3_get_numeral_decimal_string(ctx, a, precision)
功能：将实数转换为指定精度的十进制字符串。
参数：precision: unsigned（小数点后位数）。
### Z3_get_numeral_double(ctx, a, &result)
功能：将数值 AST 转换为双精度浮点数。
### Z3_get_numerator(ctx, a) / Z3_get_denominator(ctx, a)
功能：提取有理数的分子或分母（如 3/2 的分子为 3）。
### Z3_to_app(ctx, a)
功能：将通用 AST 节点转换为应用节点（需确保 Z3_is_app 为真）。
### Z3_to_func_decl(ctx, a)
功能：将应用节点的函数声明转换为 Z3_func_decl 类型。
### Z3_get_depth(ctx, a)
功能：计算 AST 的最大嵌套深度（递归子节点遍历）。
示例：表达式 f(g(x)) 的深度为 3（根节点 f → g → x）。
### Z3_get_numeral_small
从Z3数值常量（如整数或有理数）中提取C语言中的int类型值，适用于小范围整数（32位以内），若数值超出范围会返回错误。
### Z3_get_numeral_int
提取数值为C int类型，与Z3_get_numeral_small类似，但处理更通用的整数值，需确保数值在int范围内。
### Z3_get_numeral_uint
提取无符号整数到C unsigned int类型，用于处理非负整数场景。
### Z3_get_numeral_uint64
提取64位无符号整数，适用于大范围数值（如位向量或大整数模型结果）。
### Z3_get_numeral_int64
提取64位有符号整数，支持负数和大整数，常用于模型结果的数值提取。
### Z3_get_numeral_rational_int64
提取有理数值为分子和分母的64位整数对，例如分数3/2会返回num=3, den=2。
### Z3_get_algebraic_number_lower
获取代数数的有理数下界近似值，用于表示无法精确表示的代数数（如√2），参数precision控制精度。
### Z3_get_algebraic_number_upper
获取代数数的有理数上界近似值，与Z3_get_algebraic_number_lower配合使用，确定代数数的范围。
### Z3_pattern_to_ast
将模式（Pattern）对象转换为AST节点，便于与其他表达式统一处理。
### Z3_get_pattern_num_terms
返回模式中包含的子项数量。例如模式f(x, g(y))会返回2（对应x和g(y)）。
### Z3_get_pattern
获取模式中指定索引的子项（AST节点），用于分解模式结构。
### Z3_get_index_value
将索引符号（如Z3_mk_int_symbol创建的符号）转换为整数值，用于解析枚举或特定符号。
### Z3_is_quantifier_forall
判断AST节点是否为全称量词（∀），返回布尔值（Z3_TRUE或Z3_FALSE）。
### Z3_is_quantifier_exists
判断AST节点是否为存在量词（∃），与Z3_is_quantifier_forall互补。
### Z3_is_lambda
判断AST节点是否为Lambda表达式（匿名函数），用于高阶逻辑处理。
### Z3_get_quantifier_weight
获取量词的启发式权重（影响求解器优先级），权重越高可能被更早实例化。
### Z3_get_quantifier_skolem_id
获取存在量词对应的Skolem函数的唯一标识符，用于将存在量词转换为具体函数。
### Z3_get_quantifier_id
获取量词在逻辑上下文中的唯一标识符，用于跟踪或调试。
### Z3_get_quantifier_num_patterns
返回量词关联的模式数量（用于指导实例化的触发条件）。
### Z3_get_quantifier_pattern_ast
获取量词中指定索引的模式（AST节点），用于分析量词的实例化条件。
### Z3_get_quantifier_num_no_patterns
返回量词中显式排除的模式数量（避免某些实例化路径）。
### Z3_get_quantifier_no_pattern_ast
获取量词中指定索引的排除模式，防止求解器使用该模式触发实例化。
### Z3_get_quantifier_num_bound
返回量词绑定的变量数量。例如∀x y. P(x,y)会返回2。
### Z3_get_quantifier_bound_name
获取量词中指定索引的绑定变量的符号名称（如变量名x）。
### Z3_get_quantifier_bound_sort
获取量词中指定索引的绑定变量的类型（Sort），例如Int或Bool。
### Z3_get_quantifier_body
提取量词的作用域表达式（即量词后的逻辑公式部分）。例如∀x. x>0返回x>0。
### Z3_simplify
对表达式应用默认规则进行简化（如常量折叠、公式重写），返回简化后的AST。
### Z3_simplify_ex
扩展版Z3_simplify，允许传入自定义参数（如timeout或策略选项）控制简化过程。
### Z3_simplify_get_help
返回简化器支持的所有参数的帮助信息（字符串形式），用于查询可用选项。
### Z3_simplify_get_help_bytes
功能同Z3_simplify_get_help，但返回字节形式字符串，适用于某些语言绑定。
### Z3_simplify_get_param_descrs
获取简化器的参数描述集合（Z3_param_descrs对象），用于验证参数合法性。
### Z3_update_term
（注：此函数在官方文档中未明确说明，可能已弃用或用途特殊，通常Z3表达式不可变，替换操作一般通过Z3_substitute）
### Z3_substitute
将表达式中的多个符号替换为新表达式。例如用5替换所有x，支持批量替换。
### Z3_substitute_vars
按索引替换表达式中的绑定变量。例如将λx. x+y中的x（索引0）替换为z，得到λz. z+y。
### Z3_substitute_funs(ctx, ast, num_funs, from, to, result)
用途：在表达式 ast 中批量替换函数符号。将 from 数组中的函数声明替换为 to 数组中的对应声明。
参数：
num_funs: 要替换的函数数量。
from/to: 原始函数声明数组和目标函数声明数组。
result: 输出替换后的新表达式。
示例：将表达式中的函数 f 替换为 g。
### Z3_translate(source_ctx, ast, target_ctx)
用途：将表达式或模型从源上下文 (source_ctx) 转换到目标上下文 (target_ctx)，保持逻辑语义不变。
场景：跨上下文复用表达式（如多线程求解时）。
### Z3_mk_model(ctx)
用途：创建一个空的模型对象，用于存储变量和函数的赋值（即满足公式的解）。
示例：model = Z3_mk_model(ctx) 创建空模型。
### Z3_model_inc_ref(ctx, model) / Z3_model_dec_ref(ctx, model)
用途：增加/减少模型的引用计数，用于内存管理。
注意：防止内存泄漏，需成对调用。
### Z3_model_eval(ctx, model, ast, model_completion, &result)
用途：在模型 model 中计算表达式 ast 的值，结果存入 result。
参数：
model_completion: 是否补全未定义变量的默认值（true/false）。
示例：求变量 x 在模型中的值：Z3_model_eval(ctx, model, x, true, &x_val)。
### Z3_model_get_const_interp(ctx, model, const_decl)
用途：获取模型中常量（无参函数）的赋值值。
参数：const_decl 是常量的函数声明。
示例：获取常量 c 的值：val = Z3_model_get_const_interp(ctx, model, c_decl)。
### Z3_model_has_interp(ctx, model, decl)
用途：检查模型是否为声明 decl 提供了赋值（返回 true/false）。
场景：判断变量或函数是否在模型中被定义。
### Z3_model_get_func_interp(ctx, model, func_decl)
用途：获取函数声明 func_decl 在模型中的解释（即函数的定义）。
返回值：Z3_func_interp 对象，包含输入-输出对和默认值。
示例：获取函数 f(x) 的定义：fi = Z3_model_get_func_interp(ctx, model, f_decl)。
### Z3_model_get_num_consts(ctx, model)
用途：返回模型中定义的常量数量（即无参函数的数量）。
示例：n = Z3_model_get_num_consts(ctx, model)。
### Z3_model_get_const_decl(ctx, model, index)
用途：根据索引 index 获取模型中第 index 个常量的函数声明。
示例：遍历所有常量声明。
### Z3_model_get_num_funcs(ctx, model)
用途：返回模型中定义的函数数量（有参数的函数）。
### Z3_model_get_func_decl(ctx, model, index)
用途：根据索引 index 获取模型中第 index 个函数的声明。
### Z3_model_get_num_sorts(ctx, model)
用途：返回模型中定义的排序（类型）数量。
### Z3_model_get_sort(ctx, model, index)
用途：根据索引 index 获取模型中第 index 个排序。
### Z3_model_get_sort_universe(ctx, model, sort)
用途：获取排序 sort 在模型中的所有可能取值（即该类型的“宇宙”）。
返回值：Z3_ast_vector（包含所有可能值的数组）。
### Z3_model_translate(ctx, model, target_ctx)
用途：将模型转换到另一个上下文 target_ctx，类似 Z3_translate。
### Z3_is_as_array(ctx, ast)
用途：检查表达式 ast 是否表示一个“伪数组”（即通过函数模拟的数组）。
返回值：true 表示 ast 是 as-array 构造的数组。
### Z3_get_as_array_func_decl(ctx, ast)
用途：若 ast 是 as-array 构造的数组，返回其底层函数声明。
示例：将数组 A 转换为函数 f：f_decl = Z3_get_as_array_func_decl(ctx, A)。
### Z3_add_func_interp(ctx, model, func_decl, default_value)
用途：为函数声明 func_decl 添加一个函数解释，并设置默认返回值 default_value。
场景：手动构建函数解释（如自定义模型）。
### Z3_add_const_interp(ctx, model, const_decl, value)
用途：为常量声明 const_decl 设置值 value。
### Z3_func_interp_inc_ref / Z3_func_interp_dec_ref
用途：管理 Z3_func_interp 对象的引用计数。
### Z3_func_interp_get_num_entries(ctx, func_interp)
用途：获取函数解释中的输入-输出条目数量。
### Z3_func_interp_get_entry(ctx, func_interp, index)
用途：根据索引 index 获取函数解释的第 index 个条目（Z3_func_entry）。
### Z3_func_interp_get_else(ctx, func_interp)
用途：获取函数解释的默认返回值（未匹配任何条目时的值）。
### Z3_func_interp_set_else(ctx, func_interp, else_value)
用途：设置函数解释的默认返回值。
### Z3_func_interp_get_arity(ctx, func_interp)
用途：获取函数解释的参数数量（即函数的元数）。
### Z3_func_interp_add_entry(ctx, func_interp, args, value)
用途：向函数解释中添加一个输入-输出条目。
参数：
args: 参数值数组（长度等于函数元数）。
value: 对应输出值。
### Z3_func_entry_inc_ref / Z3_func_entry_dec_ref
用途：管理 Z3_func_entry 对象的引用计数。
### Z3_func_entry_get_value(ctx, func_entry)
用途：获取函数条目的输出值。
### Z3_func_entry_get_num_args(ctx, func_entry)
用途：获取函数条目的参数数量（应与函数元数一致）。
### Z3_func_entry_get_arg(ctx, func_entry, index)
用途：获取函数条目的第 index 个参数值。
### Z3_open_log
初始化日志记录功能，用于将Z3的内部操作输出到指定文件。需在调用其他日志函数前执行。
### Z3_append_log
向已打开的日志文件中追加内容，通常用于记录特定操作步骤或中间结果。
### Z3_close_log
关闭日志文件并释放相关资源，确保日志数据正确写入存储。
### Z3_toggle_warning_messages
切换警告信息的显示状态，用于控制是否在控制台输出警告（如非致命错误或潜在问题）。
### Z3_set_ast_print_mode
设置抽象语法树（AST）的字符串表示格式（如SMT-LIB2或自定义格式），影响后续转换函数的行为。
### Z3_ast_to_string
将AST节点转换为可读字符串，用于调试或展示逻辑表达式。
### Z3_ast_to_string_bytes
功能同Z3_ast_to_string，但返回字节流形式，适用于需要处理二进制数据的场景。
### Z3_pattern_to_string
将模式（Pattern）对象转换为字符串，常用于模式匹配相关的调试。
### Z3_pattern_to_string_bytes
类似Z3_pattern_to_string，输出为字节流格式。
### Z3_sort_to_string
将排序（Sort，即类型）转换为字符串表示，例如"Int"或"Bool"。
### Z3_sort_to_string_bytes
字节流版本的Z3_sort_to_string。
### Z3_func_decl_to_string
将函数声明转换为字符串，显示函数名称、参数类型及返回值类型。
### Z3_func_decl_to_string_bytes
字节流版本的函数声明转换。
### Z3_model_to_string
将模型（求解结果）转换为字符串，展示变量赋值和约束满足情况。
### Z3_model_to_string_bytes
字节流形式的模型转换。
### Z3_benchmark_to_smtlib_string
将基准测试用例转换为SMT-LIB标准格式字符串，便于复用或交换。
### Z3_benchmark_to_smtlib_string_bytes
字节流版本的SMT-LIB格式转换。
### Z3_parse_smtlib2_string
解析SMT-LIB2格式的字符串输入，生成Z3内部数据结构（如公式或约束）。
### Z3_parse_smtlib2_file
从文件中读取SMT-LIB2格式内容并解析，功能同Z3_parse_smtlib2_string但来源为文件。
### Z3_eval_smtlib2_string
执行SMT-LIB2字符串中的命令并返回结果，通常用于交互式求解。
### Z3_eval_smtlib2_string_bytes
处理字节流形式的SMT-LIB2命令输入。
### Z3_mk_parser_context
创建新的解析器上下文，用于管理自定义符号或类型解析规则。
### Z3_parser_context_inc_ref
增加解析器上下文的引用计数，防止资源被意外释放。
### Z3_parser_context_dec_ref
减少解析器上下文的引用计数，引用计数归零时释放资源。
### Z3_parser_context_add_sort
向解析器上下文中注册自定义排序（类型），扩展解析能力。
### Z3_parser_context_add_decl
向解析器上下文添加函数声明，支持解析用户定义的函数符号。
### Z3_parser_context_from_string
从字符串加载配置到解析器上下文，可能用于批量设置解析规则。
### Z3_get_error_code
获取最近一次操作的错误代码，用于判断错误类型（如参数无效或内存不足）。
### Z3_set_error
手动设置错误状态，通常用于自定义错误处理或测试。
### Z3_get_error_msg
根据错误代码返回对应的错误描述信息，辅助调试。
### Z3_get_error_msg_bytes
字节流形式的错误信息获取。
### Z3_get_version
返回Z3的版本号（如主版本号+次版本号），用于兼容性检查。
### Z3_get_full_version
获取完整版本信息（包含构建号或提交哈希等详细信息）。
### Z3_get_full_version_bytes
字节流形式的完整版本信息。
### Z3_enable_trace
启用特定模块的跟踪功能，记录详细运行时信息以供分析。
### Z3_disable_trace
关闭指定模块的跟踪，减少性能开销。
### Z3_reset_memory
重置内存管理器状态，释放临时内存但不完全终止求解器。
### Z3_finalize_memory
彻底释放Z3占用的所有内存资源，通常在程序退出前调用。
### Z3_mk_goal
创建新的求解目标（Goal），用于收集和管理逻辑公式，支持分阶段求解。
### Z3_apply_result_inc_ref
增加应用结果对象（如策略执行后的结果）的引用计数，防止被Z3内存管理提前回收。
### Z3_apply_result_dec_ref
减少应用结果对象的引用计数，引用计数归零时释放内存。

### Z3_apply_result_to_string
将应用结果（如策略生成的目标集合）转换为可读的字符串，用于调试或日志。

### Z3_apply_result_to_string_bytes
功能同Z3_apply_result_to_string，但返回字节形式字符串，适用于非ASCII环境。

### Z3_apply_result_get_num_subgoals
获取应用结果中子目标（Subgoal）的数量。例如，策略分解问题后可能生成多个子问题。

### Z3_apply_result_get_subgoal
根据索引获取指定子目标（Z3_goal对象），用于进一步处理或求解。

### Z3_mk_solver
创建默认求解器（Solver），适用于通用逻辑场景（如SMT-LIB标准兼容）。

### Z3_mk_simple_solver
创建简化版求解器，禁用部分高级优化，适用于快速原型验证。

### Z3_mk_solver_for_logic
根据指定的逻辑（如QF_BV、QF_LIA）创建预配置的求解器，优化性能。

### Z3_mk_solver_from_tactic
根据策略（Tactic）创建求解器。例如，使用qfnra策略处理非线性算术问题。

### Z3_solver_translate
将求解器及其所有断言复制到另一个Z3上下文中，用于跨上下文共享约束。

### Z3_solver_import_model_converter
导入模型转换器（Model Converter），用于在不同逻辑间转换模型。

### Z3_solver_get_help
返回求解器的帮助信息（字符串形式），说明支持的参数和配置。

### Z3_solver_get_help_bytes
同Z3_solver_get_help，但返回字节形式字符串。

### Z3_solver_get_param_descrs
获取求解器支持的参数描述集合（Z3_param_descrs对象），用于参数合法性检查。

### Z3_solver_set_params
设置求解器的参数（如超时时间timeout或随机种子random_seed）。

### Z3_solver_inc_ref
增加求解器的引用计数，防止被意外释放。

### Z3_solver_dec_ref
减少求解器的引用计数，引用计数归零时释放内存。

### Z3_solver_interrupt
中断当前求解器的运行（如超时或用户主动取消）。

### Z3_solver_push
保存当前求解器状态（类似于栈的压入操作），用于增量求解。

### Z3_solver_pop
恢复最近一次push保存的求解器状态（栈的弹出操作），撤销后续添加的断言。

### Z3_solver_reset
重置求解器，清空所有断言和状态，回到初始状态。

### Z3_solver_get_num_scopes
获取当前求解器的push操作次数（即作用域层数）。

### Z3_solver_assert
向求解器添加逻辑断言（约束条件）。例如，添加x > 0作为约束。

### Z3_solver_assert_and_track
添加断言并关联一个布尔变量（用于跟踪该断言是否被触发），便于调试冲突分析。

### Z3_solver_from_file
从文件中读取断言（SMT-LIB格式）并加载到求解器中，自动解析约束。

### Z3_solver_from_string
从字符串中读取断言（SMT-LIB格式）并加载到求解器中。

### Z3_solver_get_assertions
获取当前求解器中所有断言的AST表达式列表。

### Z3_solver_get_units
获取已被求解器确定为“单位子句”的布尔文字（如x = true或y = false）。

### Z3_solver_get_trail
获取求解器的决策路径（按顺序列出布尔变量的赋值过程），用于分析冲突。

### Z3_solver_get_non_units
获取非单位子句的断言（需要进一步处理的约束）。

### Z3_solver_get_levels
获取各布尔变量在决策路径中的层级（用于回溯算法分析）。

### Z3_solver_congruence_root
获取等价类中的代表元素（用于一致性检查）。例如，若a ≡ b，返回代表节点。

### Z3_solver_congruence_next
遍历等价类中的下一个元素，与Z3_solver_congruence_root配合使用。

### Z3_solver_congruence_explain
解释两个表达式为何属于同一等价类（生成推导步骤）。

### Z3_solver_solve_for
针对特定目标表达式进行求解，而非求解所有断言。

### Z3_solver_register_on_clause
注册回调函数，当求解器生成新子句时触发（用于自定义推理跟踪）。

### Z3_solver_propagate_init
初始化传播器（Propagator），用于自定义约束传播逻辑。

### Z3_solver_propagate_fixed
在传播过程中处理变量的固定值（如变量被赋值为常量）。

### Z3_solver_propagate_final
在传播结束时执行自定义逻辑（如清理资源或提交赋值）。
以下是按顺序逐一解释的 Z3 API 方法的用途和含义：

### Z3_simplifier_and_then(ctx, s1, s2)
用途：创建一个新的简化器（simplifier），按顺序先应用 s1，再应用 s2。
示例：s = Z3_simplifier_and_then(ctx, s1, s2) 表示 s = s1; s2。

### Z3_simplifier_using_params(ctx, s, params)
用途：为简化器 s 绑定参数配置（params 是键值对参数对象）。
场景：动态调整简化器的行为（如设置超时或启用特定优化）。

### Z3_get_num_simplifiers(ctx)
用途：返回当前上下文中注册的内置简化器数量。
示例：遍历所有内置简化器名称。

### Z3_get_simplifier_name(ctx, idx) / Z3_get_simplifier_name_bytes
用途：根据索引 idx 获取简化器的名称（字符串或字节形式）。
示例：获取第 0 个简化器的名称 "simplify"。

### Z3_simplifier_get_help(ctx, s) / Z3_simplifier_get_help_bytes
用途：获取简化器 s 的使用帮助文档（字符串或字节形式）。
场景：调试或动态生成帮助信息。

### Z3_simplifier_get_param_descrs(ctx, s)
用途：获取简化器 s 支持的参数描述集合（Z3_param_descrs 对象）。
示例：查看哪些参数可配置（如 arith.solver）。

### Z3_simplifier_get_descr(ctx, name) / Z3_simplifier_get_descr_bytes
用途：根据名称 name 获取简化器的描述信息（功能说明）。

### Z3_probe_const(ctx, val)
用途：创建一个返回固定数值 val 的探测器（probe）。
示例：p = Z3_probe_const(ctx, 1.0) 表示无论输入如何，p 始终返回 1.0。

### Z3_probe_lt(ctx, p1, p2)
用途：创建一个探测器，当 p1 的返回值 < p2 的返回值时返回 1.0，否则 0.0。
场景：组合探测器实现条件逻辑。

### Z3_probe_gt / Z3_probe_le / Z3_probe_ge / Z3_probe_eq
用途：类似 Z3_probe_lt，但比较操作符分别为 >、≤、≥、==。

### Z3_probe_and(ctx, p1, p2)
用途：创建一个逻辑与探测器，当 p1 和 p2 均返回非零值时返回 1.0，否则 0.0。

### Z3_probe_or(ctx, p1, p2)
用途：逻辑或探测器，任一探测器返回非零值时返回 1.0。

### Z3_probe_not(ctx, p)
用途：逻辑非探测器，p 返回 0.0 时返回 1.0，反之返回 0.0。

### Z3_get_num_tactics(ctx)
用途：返回当前上下文中注册的内置策略（tactic）数量。

### Z3_get_tactic_name(ctx, idx) / Z3_get_tactic_name_bytes
用途：根据索引 idx 获取策略的名称（如 "smt"、"qflia"）。

### Z3_get_num_probes(ctx)
用途：返回当前上下文中注册的内置探测器数量。

### Z3_get_probe_name(ctx, idx) / Z3_get_probe_name_bytes
用途：根据索引 idx 获取探测器的名称（如 "num-consts"）。

### Z3_tactic_get_help(ctx, t) / Z3_tactic_get_help_bytes
用途：获取策略 t 的使用帮助文档。

### Z3_tactic_get_param_descrs(ctx, t)
用途：获取策略 t 支持的参数描述集合。

### Z3_tactic_get_descr(ctx, name) / Z3_tactic_get_descr_bytes
用途：根据名称 name 获取策略的功能描述。

### Z3_probe_get_descr(ctx, name) / Z3_probe_get_descr_bytes
用途：根据名称 name 获取探测器的功能描述。

### Z3_probe_apply(ctx, p, goal)
用途：将探测器 p 应用到目标 goal 上，返回探测结果（浮点数值）。
示例：val = Z3_probe_apply(ctx, p, goal) 检测目标是否满足条件（如变量数量是否超标）。

### Z3_tactic_apply(ctx, t, goal)
用途：将策略 t 应用到目标 goal 上，返回处理后的子目标集合（Z3_apply_result）。
场景：分步求解或组合策略（如先化简再求解）。

### Z3_tactic_apply_ex(ctx, t, goal, params)
用途：扩展版策略应用，允许通过 params 参数对象配置策略行为（如超时时间）。
关键场景示例

组合探测器和策略：
// 创建探测器：目标中常量数 < 10
Z3_probe p = Z3_probe_lt(ctx, Z3_probe_const(ctx, 10), Z3_mk_probe(ctx, "num-consts"));
// 创建策略：若探测器返回真，则使用 "simplify"，否则使用 "smt"
Z3_tactic t = Z3_tactic_cond(ctx, p, Z3_mk_tactic(ctx, "simplify"), Z3_mk_tactic(ctx, "smt"));
// 应用策略到目标
Z3_apply_result res = Z3_tactic_apply(ctx, t, goal);


动态获取帮助信息：
// 获取策略 "smt" 的帮助文档
const char* help = Z3_tactic_get_help(ctx, Z3_mk_tactic(ctx, "smt"));

### Z3_goal_inc_ref
   增加目标（Goal）对象的引用计数，防止资源被提前释放。

### Z3_goal_dec_ref
   减少目标的引用计数，计数归零时释放资源。

### Z3_goal_precision
   获取目标的精度类型（如是否包含完整模型或部分推导结果）。

### Z3_goal_assert
   向目标中添加逻辑公式或约束条件，用于后续求解。

### Z3_goal_inconsistent
   检查目标是否包含矛盾的约束（即逻辑不可满足）。

### Z3_goal_depth
   返回目标当前的推导深度，反映求解过程中应用的规则层数。

### Z3_goal_reset
   清空目标中所有已添加的公式和状态，重置为初始空目标。

### Z3_goal_size
   返回目标中当前包含的公式数量。

### Z3_goal_formula
   根据索引获取目标中的特定公式。

### Z3_goal_num_exprs
    返回目标中所有表达式（包括子表达式）的总数。

### Z3_goal_is_decided_sat
    判断目标是否已被明确判定为可满足（SAT）。

### Z3_goal_is_decided_unsat
    判断目标是否已被明确判定为不可满足（UNSAT）。

### Z3_goal_translate
    将目标复制到另一个上下文（Context）中，用于跨上下文的公式迁移。

### Z3_goal_convert_model
    将目标求解得到的模型转换为当前上下文的模型表示。

### Z3_goal_to_string
    将目标内容转换为可读字符串，用于调试或日志记录。

### Z3_goal_to_string_bytes
    功能同Z3_goal_to_string，但返回字节流格式。

### Z3_goal_to_dimacs_string
    将目标转换为DIMACS格式的字符串（常用于布尔可满足性问题标准化）。

### Z3_goal_to_dimacs_string_bytes
    字节流版本的DIMACS格式转换。

### Z3_mk_tactic
    创建新的求解策略（Tactic），用于控制求解器行为（如分阶段应用规则）。

### Z3_tactic_inc_ref
    增加策略的引用计数。

### Z3_tactic_dec_ref
    减少策略的引用计数。

### Z3_mk_probe
    创建探测器（Probe），用于动态检测求解过程中的状态（如公式复杂度）。

### Z3_probe_inc_ref
    增加探测器的引用计数。

### Z3_probe_dec_ref
    减少探测器的引用计数。

### Z3_tactic_and_then
    组合两个策略，按顺序依次执行（前一个策略的输出作为后一个的输入）。

### Z3_tactic_or_else
    组合两个策略，优先尝试第一个策略，失败时回退到第二个。

### Z3_tactic_par_or
    并行执行多个策略，返回首个成功的结果。

### Z3_tactic_par_and_then
    并行执行前置策略，后续策略合并结果。

### Z3_tactic_try_for
    为策略设置时间限制（单位毫秒），超时则终止。

### Z3_tactic_when
    条件执行策略：仅当探测器满足条件时执行目标策略。

### Z3_tactic_cond
    根据探测器返回值选择执行的分支策略。

### Z3_tactic_repeat
    重复执行策略直至无法进一步简化或达到固定次数。

### Z3_tactic_skip
    创建一个空策略，直接返回当前目标（无操作）。

### Z3_tactic_fail
    始终失败的策略，用于组合逻辑中的错误处理。

### Z3_tactic_fail_if
    当探测器返回特定条件时强制失败。

### Z3_tactic_fail_if_not_decided
    若策略未明确判定SAT/UNSAT则视为失败。

### Z3_tactic_using_params
    为策略绑定配置参数（如启发式规则开关）。

### Z3_mk_simplifier
    创建简化器（Simplifier），用于逻辑表达式的化简（如常量折叠）。

### Z3_simplifier_inc_ref
    增加简化器的引用计数。

### Z3_simplifier_dec_ref
    减少简化器的引用计数。

### Z3_solver_add_simplifier
    将简化器绑定到求解器，自动应用化简规则。

### Z3_algebraic_get_i
获取代数数在内部多项式系统中的唯一索引，用于标识代数数对象。

### Z3_polynomial_subresultants
计算两个多项式的子结式序列，用于判断多项式间的关系或根的存在性。

### Z3_rcf_del
释放实数闭域（RCF）数对象的内存，避免内存泄漏。

### Z3_rcf_mk_rational
从有理数（如3/4）创建RCF数对象，支持精确分数表示。

### Z3_rcf_mk_small_int
快速创建小整数的RCF数（如5），优化性能。

### Z3_rcf_mk_pi
创建数学常数π（圆周率）的RCF数对象。

### Z3_rcf_mk_e
创建自然对数的底数e的RCF数对象。

### Z3_rcf_mk_infinitesimal
创建无穷小量（ε）的RCF数，用于非标准分析或近似计算。

### Z3_rcf_mk_roots
根据多项式创建其所有实根的RCF数集合（如x²-2=0生成√2和-√2）。

### Z3_rcf_add
对两个RCF数执行加法运算（如a + b）。

### Z3_rcf_sub
执行减法运算（如a - b）。

### Z3_rcf_mul
执行乘法运算（如a * b）。

### Z3_rcf_div
执行除法运算（如a / b），要求分母非零。

### Z3_rcf_neg
取负数运算（如-a）。

### Z3_rcf_inv
取倒数运算（如1/a）。

### Z3_rcf_power
计算RCF数的整数次幂（如a^n，n为整数）。

### Z3_rcf_lt
判断两个RCF数是否满足小于关系（a < b）。

### Z3_rcf_gt
判断大于关系（a > b）。

### Z3_rcf_le
判断小于等于关系（a ≤ b）。

### Z3_rcf_ge
判断大于等于关系（a ≥ b）。

### Z3_rcf_eq
判断相等性（a = b）。

### Z3_rcf_neq
判断不等性（a ≠ b）。

### Z3_rcf_num_to_string
将RCF数转换为可读字符串（如√2或3/4）。

### Z3_rcf_num_to_string_bytes
功能同上，但返回字节形式字符串。

### Z3_rcf_num_to_decimal_string
转换为十进制近似字符串（如1.4142表示√2）。

### Z3_rcf_num_to_decimal_string_bytes
同上，返回字节形式。

### Z3_rcf_get_numerator_denominator
提取RCF有理数的分子和分母（如3/4返回num=3, den=4）。

### Z3_rcf_is_rational
判断RCF数是否为有理数（如5或1/2）。

### Z3_rcf_is_algebraic
判断是否为代数数（如√2是多项式x²-2的根）。

### Z3_rcf_is_infinitesimal
判断是否为无穷小量（ε）。

### Z3_rcf_is_transcendental
判断是否为超越数（如π或e）。

### Z3_rcf_extension_index
获取代数数在扩展域中的索引，用于构造层次化代数系统。

### Z3_rcf_transcendental_name
获取超越数的名称（如"pi"或"e"）。

### Z3_rcf_infinitesimal_name
获取无穷小量的符号名称（如"epsilon"）。

### Z3_rcf_num_coefficients
返回代数数对应多项式的系数数量（如x²-2有3个系数）。

### Z3_rcf_coefficient
获取代数数多项式中指定索引的系数（如索引1对应x²-2的0次项系数-2）。

### Z3_rcf_interval
获取RCF数的区间近似（如√2 ∈ [1.414, 1.415]）。

### Z3_rcf_num_sign_conditions
返回符号条件数量（用于判断多项式在特定区间的符号变化）。

### Z3_rcf_sign_condition_sign
获取指定符号条件的符号值（正、负或零）。

### Z3_rcf_num_sign_condition_coefficients
返回符号条件关联的系数数量（用于分析多项式根的分布）。

### Z3_ast_vector_size(ctx, vec)
用途：返回 AST 向量（Z3_ast_vector）中元素的个数。
参数：vec 是 Z3_ast_vector 对象。
示例：遍历向量时获取长度 size = Z3_ast_vector_size(ctx, vec)。

### Z3_ast_vector_get(ctx, vec, idx)
用途：获取 AST 向量中索引为 idx 的 AST 节点。
注意：索引从 0 开始，需确保 idx < size。

### Z3_ast_vector_set(ctx, vec, idx, ast)
用途：将 AST 向量中索引为 idx 的位置设置为 ast。
场景：修改向量中的某个元素。

### Z3_ast_vector_resize(ctx, vec, new_size)
用途：调整 AST 向量的大小为 new_size。
注意：若 new_size < 原大小，截断多余元素；若 new_size > 原大小，新增位置未初始化。

### Z3_ast_vector_push(ctx, vec, ast)
用途：将 AST 节点 ast 添加到向量末尾，并增加向量大小。

### Z3_ast_vector_translate(ctx, vec, target_ctx)
用途：将整个 AST 向量转换到目标上下文 target_ctx，生成新向量。
场景：跨上下文复用 AST 集合。

### Z3_ast_vector_to_string(ctx, vec) / Z3_ast_vector_to_string_bytes
用途：将 AST 向量转换为可读字符串（如调试输出）。

### Z3_mk_ast_map(ctx)
用途：创建一个空的 AST 映射（键值对，键和值均为 Z3_ast 类型）。

### Z3_ast_map_inc_ref(ctx, map) / Z3_ast_map_dec_ref
用途：管理 AST 映射的引用计数，防止内存泄漏。

### Z3_ast_map_contains(ctx, map, key)
用途：检查映射中是否包含键 key，返回 true/false。

### Z3_ast_map_find(ctx, map, key)
用途：查找键 key 对应的值，若不存在返回 NULL。

### Z3_ast_map_insert(ctx, map, key, value)
用途：向映射中插入键值对 key → value，若键已存在则覆盖。

### Z3_ast_map_erase(ctx, map, key)
用途：删除键 key 对应的条目。

### Z3_ast_map_reset(ctx, map)
用途：清空映射中的所有条目。

### Z3_ast_map_size(ctx, map)
用途：返回映射中键值对的数量。

### Z3_ast_map_keys(ctx, map)
用途：返回映射中所有键组成的 AST 向量。

### Z3_ast_map_to_string / Z3_ast_map_to_string_bytes
用途：将映射内容转换为字符串（用于调试或日志）。

### Z3_algebraic_is_value(ctx, a)
用途：判断 AST a 是否是一个具体的代数数值（而非未化简的表达式）。
返回值：true 表示 a 已化简为确定值（如 √2 的数值形式）。

### Z3_algebraic_is_pos(ctx, a) / Z3_algebraic_is_neg / Z3_algebraic_is_zero
用途：检查代数数 a 的符号是否为正、负或零。
示例：Z3_algebraic_is_zero(ctx, a) 判断 a 是否等于 0。

### Z3_algebraic_sign(ctx, a)
用途：返回代数数的符号：正数返回 1，负数返回 -1，零返回 0。

### Z3_algebraic_add(ctx, a, b) / sub / mul / div
用途：对两个代数数 a 和 b 执行四则运算，返回结果代数数。
限制：除法时需确保 b ≠ 0。

### Z3_algebraic_root(ctx, a, n)
用途：计算代数数 a 的 n 次方根（需 a ≥ 0 且 n > 0）。

### Z3_algebraic_power(ctx, a, n)
用途：计算代数数 a 的 n 次幂（n 为整数）。

### Z3_algebraic_lt / gt / le / ge / eq / neq
用途：比较两个代数数的大小或相等性，返回布尔结果（true/false）。

### Z3_algebraic_roots(ctx, p, num_vars, vars)
用途：求解多项式 p 的根（返回所有满足 p = 0 的代数数）。
参数：
p: 多项式表达式。
vars: 变量列表（多项式中的变量名）。

### Z3_algebraic_eval(ctx, p, num_args, args)
用途：对多项式 p 代入参数 args 进行计算，返回结果代数数。

### Z3_algebraic_get_poly(ctx, a, idx)
用途：获取代数数 a 的最小多项式（多项式系数列表）中的第 idx 项。
场景：分析代数数的数学性质。
关键操作说明
代数数运算：所有代数数操作均基于精确的符号计算，避免浮点误差。
AST 容器：Z3_ast_vector 和 Z3_ast_map 用于批量管理 AST 节点，适合复杂表达式处理。
映射操作：Z3_ast_map 可用于实现 AST 的替换表或缓存计算结果。

### Z3_solver_propagate_eq
在求解过程中传播等式约束，用于推导变量间的等价关系，优化搜索空间。

### Z3_solver_propagate_diseq
传播不等式约束，推导变量间的非等价关系。

### Z3_solver_propagate_created
处理新约束的传播事件，可能在动态添加约束时触发。

### Z3_solver_propagate_decide
传播分支决策（如变量赋值）的影响，用于指导搜索方向。

### Z3_solver_next_split
指示求解器进行下一次分支或分割操作（例如在回溯时选择新路径）。

### Z3_solver_propagate_declare
声明自定义传播规则或事件类型，扩展求解器的推导能力。

### Z3_solver_propagate_register
注册传播处理器，用于响应特定约束类型的推导事件。

### Z3_solver_propagate_register_cb
注册回调函数（Callback）到传播事件，实现自定义推导逻辑。

### Z3_solver_propagate_consequence
传播逻辑推导的直接后果（如新约束的生成）。

### Z3_solver_set_initial_value
设置变量的初始值或搜索起点，可能用于引导启发式策略。

### Z3_solver_check
检查当前约束的可满足性，返回SAT、UNSAT或UNKNOWN。

### Z3_solver_check_assumptions
在给定临时假设（如额外约束）下检查可满足性，假设不永久生效。

### Z3_get_implied_equalities
获取当前上下文中隐含的等式集合（如由约束推导出的变量等价关系）。

### Z3_solver_get_consequences
获取逻辑后果，即当前约束下必须成立的所有条件（如变量取值范围）。

### Z3_solver_cube
生成分治求解的候选解块（Cube），用于并行或分阶段求解。

### Z3_solver_get_model
获取满足约束的模型（变量赋值），仅在结果为SAT时有效。

### Z3_solver_get_proof
获取不可满足性证明的步骤（如解析树），需启用证明生成功能。

### Z3_solver_get_unsat_core
提取导致不可满足的最小约束子集（用于诊断冲突原因）。

### Z3_solver_get_reason_unknown
获取求解器返回UNKNOWN状态的详细原因描述（如超时或资源耗尽）。

### Z3_solver_get_reason_unknown_bytes
字节流形式的未知原因描述。

### Z3_solver_get_statistics
返回求解过程的统计信息对象（如时间、内存、推导步骤数）。

### Z3_solver_to_string
将求解器状态转换为可读字符串（含当前约束和配置）。

### Z3_solver_to_string_bytes
字节流形式的求解器状态字符串。

### Z3_solver_to_dimacs_string
将布尔约束转换为DIMACS格式字符串（标准化SAT问题交换）。

### Z3_solver_to_dimacs_string_bytes
字节流版本的DIMACS格式转换。

### Z3_stats_to_string
将统计信息对象转换为可读字符串（如键值对列表）。

### Z3_stats_to_string_bytes
字节流形式的统计信息字符串。

### Z3_stats_inc_ref
增加统计信息对象的引用计数。

### Z3_stats_dec_ref
减少统计信息对象的引用计数，计数归零时释放资源。

### Z3_stats_size
返回统计信息中的条目数量。

### Z3_stats_get_key
根据索引获取统计条目的名称（如"memory"或"time"）。

### Z3_stats_get_key_bytes
字节流形式的统计条目名称。

### Z3_stats_is_uint
判断统计值是否为无符号整数类型（如推导步骤数）。

### Z3_stats_is_double
判断统计值是否为双精度浮点数（如CPU时间）。

### Z3_stats_get_uint_value
获取无符号整数值类型的统计条目数值。

### Z3_stats_get_double_value
获取双精度浮点数类型的统计条目数值。

### Z3_get_estimated_alloc_size
估算Z3当前占用的内存总量（用于性能调优或资源监控）。

### Z3_mk_ast_vector
创建AST（抽象语法树）容器，用于批量存储逻辑表达式。

### Z3_ast_vector_inc_ref
增加AST向量的引用计数。

### Z3_ast_vector_dec_ref
减少AST向量的引用计数，计数归零时释放容器及内容。

### Z3_optimize_get_lower(ctx, opt, idx)
用途：获取优化目标中第 idx 个目标的下界（当前最优解的最小可能值）。
参数：idx 是目标索引（从 0 开始）。
返回值：Z3_ast 表达式，表示数值下界（如 10）。

### Z3_optimize_get_upper(ctx, opt, idx)
用途：获取第 idx 个目标的上界（当前最优解的最大可能值）。

### Z3_optimize_get_lower_as_vector(ctx, opt, idx) / Z3_optimize_get_upper_as_vector
用途：以向量形式返回多目标优化中第 idx 个目标的下界/上界集合（适用于多个边界值）。

### Z3_optimize_to_string(ctx, opt) / Z3_optimize_to_string_bytes
用途：将优化器的状态（如约束、目标）转换为字符串（用于调试或保存状态）。

### Z3_optimize_from_string(ctx, opt, str) / Z3_optimize_from_file
用途：从字符串或文件加载优化器状态（反序列化）。

### Z3_optimize_get_help(ctx, opt) / Z3_optimize_get_help_bytes
用途：获取优化器的帮助文档（支持的参数和功能说明）。

### Z3_optimize_get_statistics(ctx, opt)
用途：返回优化器的统计信息（如求解时间、迭代次数），类型为 Z3_stats。

### Z3_optimize_get_assertions(ctx, opt)
用途：获取优化器中添加的所有约束（Z3_ast_vector）。

### Z3_optimize_get_objectives(ctx, opt)
用途：获取所有优化目标（Z3_ast_vector）。

### Z3_mk_fpa_rounding_mode_sort(ctx)
用途：创建浮点舍入模式（Rounding Mode）的排序（Sort）。
示例：sort = Z3_mk_fpa_rounding_mode_sort(ctx) 表示舍入模式类型。
舍入模式常量：
Z3_mk_fpa_round_nearest_ties_to_even / Z3_mk_fpa_rne
用途：创建“就近舍入，偶数优先”的舍入模式（IEEE 754 默认）。
Z3_mk_fpa_round_nearest_ties_to_away / Z3_mk_fpa_rna
用途：创建“就近舍入，远离零优先”的舍入模式。
Z3_mk_fpa_round_toward_positive / Z3_mk_fpa_rtp
用途：向正无穷方向舍入。
Z3_mk_fpa_round_toward_negative / Z3_mk_fpa_rtn
用途：向负无穷方向舍入。
Z3_mk_fpa_round_toward_zero / Z3_mk_fpa_rtz
用途：向零方向舍入（截断）。

### Z3_mk_fpa_sort(ctx, ebits, sbits)
用途：自定义浮点类型，指数位 ebits，尾数位 sbits。
示例：Z3_mk_fpa_sort(ctx, 8, 24) 表示单精度浮点（实际为 8 指数位 + 23 尾数位 + 1 隐藏位）。
预定义类型：
Z3_mk_fpa_sort_half / Z3_mk_fpa_sort_16：半精度（16 位）。
Z3_mk_fpa_sort_single / Z3_mk_fpa_sort_32：单精度（32 位）。
Z3_mk_fpa_sort_double / Z3_mk_fpa_sort_64：双精度（64 位）。

### Z3_mk_fpa_nan(ctx, sort)：创建 NaN（非数值）。
### Z3_mk_fpa_inf(ctx, sort, sign)：创建正/负无穷（sign 为 true 表示负）。
### Z3_mk_fpa_zero(ctx, sort, sign)：创建正/负零。

### Z3_mk_fpa_fp(ctx, sgn, exp, sig)
用途：通过符号位 sgn、指数 exp、尾数 sig 构造浮点数。
参数：均为 Z3_ast 表达式（需符合浮点位宽约束）。
Z3_mk_fpa_numeral_float / Z3_mk_fpa_numeral_double
用途：从 C 浮点数（float/double）创建浮点常量。
Z3_mk_fpa_numeral_int / Z3_mk_fpa_numeral_int_uint / Z3_mk_fpa_numeral_int64_uint64
用途：从整数或位模式创建浮点常量。

### Z3_mk_fpa_abs(ctx, t)：取绝对值。
### Z3_mk_fpa_neg(ctx, t)：取相反数。
### Z3_mk_fpa_add(ctx, rm, t1, t2)：加法（需指定舍入模式 rm）。
### Z3_mk_fpa_sub(ctx, rm, t1, t2)：减法。

### Z3_mk_fpa_mul
创建浮点数乘法表达式，接受舍入模式（Rounding Mode）、两个浮点数操作数，返回结果表达式。

### Z3_mk_fpa_div
创建浮点数除法表达式，格式：(rounding_mode, x, y) → x / y。

### Z3_mk_fpa_fma
创建融合乘加（Fused Multiply-Add）表达式：(x * y) + z，单次舍入，提升精度。

### Z3_mk_fpa_sqrt
创建浮点数平方根表达式：sqrt(x)，需指定舍入模式。

### Z3_mk_fpa_rem
创建浮点数取余表达式，返回x - n*y（余数符号与x相同，n为整数商）。

### Z3_mk_fpa_round_to_integral
将浮点数舍入到最近的整数表达式，需指定舍入模式。

### Z3_mk_fpa_min
返回两个浮点数中的最小值（遵循IEEE 754规则，处理NaN和符号）。

### Z3_mk_fpa_max
返回两个浮点数中的最大值（处理规则同Z3_mk_fpa_min）。

### Z3_mk_fpa_leq
创建浮点数“小于等于”比较表达式（x ≤ y），返回布尔值。

### Z3_mk_fpa_lt
创建“小于”比较表达式（x < y）。

### Z3_mk_fpa_geq
创建“大于等于”比较表达式（x ≥ y）。

### Z3_mk_fpa_gt
创建“大于”比较表达式（x > y）。

### Z3_mk_fpa_eq
创建浮点数相等性表达式（x = y），需注意NaN不等于任何值（包括自身）。

### Z3_mk_fpa_is_normal
创建判断浮点数是否为规格化数（Normal）的条件表达式。

### Z3_mk_fpa_is_subnormal
创建判断是否为非规格化数（Subnormal，即Denormal）的条件。

### Z3_mk_fpa_is_zero
创建判断浮点数是否为零的条件。

### Z3_mk_fpa_is_infinite
创建判断是否为无穷大（+∞或-∞）的条件。

### Z3_mk_fpa_is_nan
创建判断是否为非数值（NaN）的条件。

### Z3_mk_fpa_is_negative
创建判断浮点数是否为负的条件（包括负零）。

### Z3_mk_fpa_is_positive
创建判断是否为正的条件（包括正零）。

### Z3_mk_fpa_to_fp_bv
将位向量转换为浮点数表达式，需目标浮点类型和舍入模式。

### Z3_mk_fpa_to_fp_float
将另一个浮点数转换为目标浮点类型表达式，需舍入模式。

### Z3_mk_fpa_to_fp_real
将实数（理论实数，非浮点）转换为浮点数表达式，需舍入模式。

### Z3_mk_fpa_to_fp_signed
将有符号整数转换为浮点数表达式，需舍入模式。

### Z3_mk_fpa_to_fp_unsigned
将无符号整数转换为浮点数表达式，需舍入模式。

### Z3_mk_fpa_to_ubv
将浮点数转换为无符号位向量表达式，需舍入模式和目标位宽。

### Z3_mk_fpa_to_sbv
转换为有符号位向量表达式，需舍入模式和位宽。

### Z3_mk_fpa_to_real
将浮点数转换为理论实数表达式（可能丢失精度，仅符号和数值信息）。

### Z3_fpa_get_ebits
获取浮点数格式的指数部分位数（如单精度为8位）。

### Z3_fpa_get_sbits
获取浮点数格式的有效数（Significand，即尾数）位数（单精度为23+1隐藏位）。

### Z3_fpa_is_numeral_nan
检查浮点数常量是否为NaN。

### Z3_fpa_is_numeral_inf
检查是否为无穷大（+∞或-∞）。

### Z3_fpa_is_numeral_zero
检查是否为零（正零或负零）。

### Z3_fpa_is_numeral_normal
检查是否为规格化数。

### Z3_fpa_is_numeral_subnormal
检查是否为非规格化数。

### Z3_fpa_is_numeral_positive
检查浮点数常量是否为正（包括正零、正无穷）。

### Z3_fpa_is_numeral_negative
检查是否为负（包括负零、负无穷）。

### Z3_fpa_get_numeral_sign_bv
获取浮点常量的符号位位向量（1位，0为正，1为负）。

### Z3_fpa_get_numeral_significand_bv
获取有效数部分的位向量表示（不含隐藏位）。

### Z3_fpa_get_numeral_sign
获取符号的整数值（0为正，1为负）。

### Z3_fpa_get_numeral_significand_string
获取有效数的十进制字符串表示（如"1.5"）。

### Z3_rcf_sign_condition_coefficient
获取实数闭域（RCF）理论中符号条件（如多项式符号判定）的系数，用于数学推导。

### Z3_mk_fixedpoint
创建固定点（Fixedpoint）求解器实例，用于不动点计算（如Datalog规则推理）。

### Z3_fixedpoint_inc_ref
增加固定点求解器的引用计数，防止资源提前释放。

### Z3_fixedpoint_dec_ref
减少引用计数，计数归零时释放资源。

### Z3_fixedpoint_add_rule
向固定点求解器添加推理规则（如Horn子句），定义逻辑推导过程。

### Z3_fixedpoint_add_fact
添加基础事实（Ground Fact）作为初始条件，用于推导新结论。

### Z3_fixedpoint_assert
直接添加逻辑公式到固定点求解器的约束集合中。

### Z3_fixedpoint_query
执行固定点计算，验证是否可从当前规则和事实推导出某结论。

### Z3_fixedpoint_query_relations
查询特定关系（Relation）的推导结果，如数据库视图的生成。

### Z3_fixedpoint_get_answer
获取查询的结果（如推导出的具体赋值或证明）。

### Z3_fixedpoint_get_reason_unknown
返回固定点求解失败的原因描述（如超时或规则冲突）。

### Z3_fixedpoint_get_reason_unknown_bytes
字节流形式的失败原因。

### Z3_fixedpoint_update_rule
动态更新已有规则，支持增量式逻辑修改。

### Z3_fixedpoint_get_num_levels
获取推导过程中生成的层次数（如不动点迭代次数）。

### Z3_fixedpoint_get_cover_delta
提取覆盖差异（Cover Delta），用于分析推导结果的增量变化。

### Z3_fixedpoint_add_cover
添加覆盖约束，限制关系的可能实例化范围。

### Z3_fixedpoint_get_statistics
返回固定点求解的统计信息（如时间、内存、规则应用次数）。

### Z3_fixedpoint_register_relation
注册自定义关系（Relation）到求解器，扩展逻辑表达能力。

### Z3_fixedpoint_set_predicate_representation
设置谓词（Predicate）的内部表示方式（如位向量或枚举）。

### Z3_fixedpoint_get_rules
获取当前所有已添加的规则集合。

### Z3_fixedpoint_get_assertions
返回已添加的所有基础事实和约束。

### Z3_fixedpoint_set_params
配置固定点求解器的参数（如超时或启发式策略）。

### Z3_fixedpoint_get_help
获取固定点求解器的帮助文档（如参数说明）。

### Z3_fixedpoint_get_help_bytes
字节流形式的帮助信息。

### Z3_fixedpoint_get_param_descrs
返回固定点求解器的参数描述对象，用于动态查询参数选项。

### Z3_fixedpoint_to_string
将当前规则、事实和配置转换为可读字符串。

### Z3_fixedpoint_to_string_bytes
字节流形式的字符串表示。

### Z3_fixedpoint_from_string
从字符串加载规则和事实到固定点求解器。

### Z3_fixedpoint_from_file
从文件读取规则和事实并加载到求解器。

### Z3_mk_optimize
创建优化求解器（Optimize）实例，支持目标函数最大化/最小化。

### Z3_optimize_inc_ref
增加优化求解器的引用计数。

### Z3_optimize_dec_ref
减少引用计数，计数归零时释放资源。

### Z3_optimize_assert
添加硬约束到优化求解器，必须满足的条件。

### Z3_optimize_assert_and_track
添加带标记的约束，用于后续提取冲突核心。

### Z3_optimize_assert_soft
添加软约束（可违反但需最小化/最大化其权重）。

### Z3_optimize_maximize
定义最大化目标函数（如最大化变量值）。

### Z3_optimize_minimize
定义最小化目标函数（如最小化成本）。

### Z3_optimize_push
保存当前求解状态到栈中，支持回溯。

### Z3_optimize_pop
恢复之前保存的状态（回退到最近一次push）。

### Z3_optimize_set_initial_value
设置变量的初始值，引导启发式搜索方向。

### Z3_optimize_check
检查约束的可满足性并计算最优解，返回SAT/UNSAT/UNKNOWN。

### Z3_optimize_get_reason_unknown
获取优化失败的原因（如无解或超时）。

### Z3_optimize_get_reason_unknown_bytes
字节流形式的失败原因。

### Z3_optimize_get_model
返回满足约束且优化目标最优的模型。

### Z3_optimize_get_unsat_core
提取导致不可满足的最小硬约束子集。

### Z3_optimize_set_params
设置优化求解器的参数（如求解算法或时间限制）。

### Z3_optimize_get_param_descrs
返回优化求解器的参数描述对象。

### Z3_fpa_get_numeral_significand_string_bytes
以字节形式返回浮点常量的有效数（Significand）十进制字符串表示，例如"1.5"转换为字节序列[^7][^8]。

### Z3_fpa_get_numeral_significand_uint64
将有效数部分转换为64位无符号整数（需确保有效数不超出此范围）[^7][^8]。

### Z3_fpa_get_numeral_exponent_string
获取浮点常量指数的十进制字符串（如指数2转换为"2"）[^7][^8]。

### Z3_fpa_get_numeral_exponent_string_bytes
功能同上，但返回字节形式的指数字符串[^7][^8]。

### Z3_fpa_get_numeral_exponent_int64
返回指数的64位有符号整数值（适用于常规指数范围）[^7][^8]。

### Z3_fpa_get_numeral_exponent_bv
获取指数的位向量表示（如指数为3时返回0011）[^7][^8]。

### Z3_mk_fpa_to_ieee_bv
将浮点数转换为符合IEEE 754标准的位向量表达式（如单精度浮点转换为32位向量）[^7]。

### Z3_mk_fpa_to_fp_int_real
结合整数和实数参数生成浮点数表达式（需指定舍入模式）[^7][^8]。

### Z3_fixedpoint_query_from_lvl
从指定层级发起固定点查询，用于分层逻辑推理（如循环不变式推导）[^3]。

### Z3_fixedpoint_get_ground_sat_answer
获取满足地面（无变量）约束的答案（用于确定逻辑程序的可满足性）[^3]。

### Z3_fixedpoint_get_rules_along_trace
提取推理路径中触发的规则列表（用于调试或分析规则应用顺序）[^3]。

### Z3_fixedpoint_get_rule_names_along_trace
返回规则名称列表（与get_rules_along_trace配合，便于语义追踪）[^3]。

### Z3_fixedpoint_add_invariant
向固定点求解器添加不变量约束（用于增强循环或递归逻辑的推理）[^3]。

### Z3_fixedpoint_get_reachable
获取可达状态集合（如模型检测中验证安全性属性）[^3]。

### Z3_qe_model_project
将模型投影到指定变量子集，忽略其他变量（用于简化模型输出）[^5][^7]。

### Z3_qe_model_project_skolem
带Skolem函数的模型投影，处理存在量词时生成依赖变量的赋值[^5]。

### Z3_qe_model_project_with_witness
提供附加证据的投影，验证投影结果的正确性[^5]。

### Z3_model_extrapolate
推断模型的泛化版本（扩展模型适用范围，如参数化系统）[^5]。

### Z3_qe_lite
执行轻量级量化消除，简化包含存在量词的公式（适用于部分场景）[^5]。
